#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#include <stdio.h>
#include <io.h>
#include <stdlib.h>

#define HOTKEY_BASE 1
#define HOTKEY_COUNT 9
#define ID_SAVE_BUTTON 100
#define IDC_ENABLE_AUTO 101
#define IDC_STARTUP 102
#define WM_TRAYICON (WM_USER + 1)
#define TRAY_MENU_OPEN 2001
#define TRAY_MENU_EXIT 2002

HWND hEdit[HOTKEY_COUNT];
HWND hCheckEnable, hCheckStartup;
wchar_t infoListW[HOTKEY_COUNT][1024] = {0};
HINSTANCE g_hInst;
BOOL gEnableAuto = TRUE;
NOTIFYICONDATA nid;
wchar_t configPath[MAX_PATH];
HBITMAP hBackground = NULL;
HICON hAppIcon = NULL;

// -------------------- 获取配置文件路径 --------------------
void GetConfigPath() {
    wchar_t appData[MAX_PATH];
    if (SUCCEEDED(SHGetFolderPathW(NULL, CSIDL_APPDATA, NULL, 0, appData))) {
        wchar_t dirPath[MAX_PATH];
        swprintf(dirPath, MAX_PATH, L"%s\\AutoInputTool", appData);
        CreateDirectoryW(dirPath, NULL);
        swprintf(configPath, MAX_PATH, L"%s\\AutoInputTool\\config.ini", appData);
    } else {
        swprintf(configPath, MAX_PATH, L".\\config.ini");
    }
}

// -------------------- 保存配置 --------------------
BOOL SaveConfigString(LPCWSTR section, LPCWSTR key, LPCWSTR value) {
    return WritePrivateProfileStringW(section, key, value, configPath);
}

// -------------------- 初始化默认配置（首次运行） --------------------
void InitConfig() {
    if (_waccess(configPath, 0) != 0) {  // 文件不存在
        wchar_t defaultValues[HOTKEY_COUNT][1024] = {
            L"13812345678",
            L"yourmail@example.com",
            L"你好，世界！",
            L"", L"", L"", L"", L"", L""
        };
        for (int i = 0; i < HOTKEY_COUNT; i++) {
            wchar_t key[16];
            swprintf(key, 16, L"Key%d", i+1);
            SaveConfigString(L"Settings", key, defaultValues[i]);
        }
        SaveConfigString(L"Settings", L"EnableAuto", L"1");
        SaveConfigString(L"Settings", L"Startup", L"0");
    }
}

// -------------------- 加载配置 --------------------
void LoadConfig(HWND hwnd) {
    gEnableAuto = GetPrivateProfileIntW(L"Settings", L"EnableAuto", 1, configPath);
    int startup = GetPrivateProfileIntW(L"Settings", L"Startup", 0, configPath);
    CheckDlgButton(hwnd, IDC_ENABLE_AUTO, gEnableAuto ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(hwnd, IDC_STARTUP, startup ? BST_CHECKED : BST_UNCHECKED);

    for (int i = 0; i < HOTKEY_COUNT; i++) {
        wchar_t key[16];
        swprintf(key, 16, L"Key%d", i+1);
        GetPrivateProfileStringW(L"Settings", key, L"", infoListW[i], 1024, configPath);
        SetWindowTextW(hEdit[i], infoListW[i]);
    }

    for (int i = 0; i < HOTKEY_COUNT; i++) {
        if (gEnableAuto)
            RegisterHotKey(hwnd, HOTKEY_BASE + i, MOD_ALT, '1' + i);
        else
            UnregisterHotKey(hwnd, HOTKEY_BASE + i);
    }
}

// -------------------- 保存配置 --------------------
void SaveConfig(HWND hwnd) {
    gEnableAuto = (IsDlgButtonChecked(hwnd, IDC_ENABLE_AUTO) == BST_CHECKED);
    BOOL startup = (IsDlgButtonChecked(hwnd, IDC_STARTUP) == BST_CHECKED);

    SaveConfigString(L"Settings", L"EnableAuto", gEnableAuto ? L"1" : L"0");
    SaveConfigString(L"Settings", L"Startup", startup ? L"1" : L"0");

    for (int i = 0; i < HOTKEY_COUNT; i++) {
        GetWindowTextW(hEdit[i], infoListW[i], 1024);
        wchar_t key[16];
        swprintf(key, 16, L"Key%d", i+1);
        SaveConfigString(L"Settings", key, infoListW[i]);
    }

    // 开机启动注册表
    HKEY hKey;
    if (RegOpenKeyExW(HKEY_CURRENT_USER,
        L"Software\\Microsoft\\Windows\\CurrentVersion\\Run",
        0, KEY_SET_VALUE, &hKey) == ERROR_SUCCESS)
    {
        wchar_t path[MAX_PATH];
        GetModuleFileNameW(NULL, path, MAX_PATH);
        if (startup)
            RegSetValueExW(hKey, L"AutoInputTool", 0, REG_SZ, (BYTE*)path, (wcslen(path) + 1) * sizeof(wchar_t));
        else
            RegDeleteValueW(hKey, L"AutoInputTool");
        RegCloseKey(hKey);
    }

    for (int i = 0; i < HOTKEY_COUNT; i++) {
        if (gEnableAuto)
            RegisterHotKey(hwnd, HOTKEY_BASE + i, MOD_ALT, '1' + i);
        else
            UnregisterHotKey(hwnd, HOTKEY_BASE + i);
    }

    MessageBoxW(hwnd, L"设置已保存！", L"提示", MB_OK);
}

// -------------------- Clipboard + Ctrl+V --------------------
void setClipboardTextW(const wchar_t* text) {
    if (!text || wcslen(text) == 0) return;
    HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, (wcslen(text) + 1) * sizeof(wchar_t));
    if (!hMem) return;
    memcpy(GlobalLock(hMem), text, (wcslen(text) + 1) * sizeof(wchar_t));
    GlobalUnlock(hMem);

    if (OpenClipboard(NULL)) {
        EmptyClipboard();
        SetClipboardData(CF_UNICODETEXT, hMem);
        CloseClipboard();
    } else {
        GlobalFree(hMem);
    }
}

void pasteClipboard() {
    BOOL altPressed = (GetAsyncKeyState(VK_MENU) & 0x8000) != 0;
    INPUT ip[6] = { 0 };
    int idx = 0;
    if (altPressed) { ip[idx].type = INPUT_KEYBOARD; ip[idx].ki.wVk = VK_MENU; ip[idx].ki.dwFlags = KEYEVENTF_KEYUP; idx++; }
    ip[idx].type = INPUT_KEYBOARD; ip[idx].ki.wVk = VK_CONTROL; idx++;
    ip[idx].type = INPUT_KEYBOARD; ip[idx].ki.wVk = 'V'; idx++;
    ip[idx].type = INPUT_KEYBOARD; ip[idx].ki.wVk = 'V'; ip[idx].ki.dwFlags = KEYEVENTF_KEYUP; idx++;
    ip[idx].type = INPUT_KEYBOARD; ip[idx].ki.wVk = VK_CONTROL; ip[idx].ki.dwFlags = KEYEVENTF_KEYUP; idx++;
    if (altPressed) { ip[idx].type = INPUT_KEYBOARD; ip[idx].ki.wVk = VK_MENU; idx++; }
    SendInput(idx, ip, sizeof(INPUT));
}

// -------------------- 窗口回调 --------------------
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg) {
    case WM_COMMAND:
        if (LOWORD(wParam) == ID_SAVE_BUTTON) SaveConfig(hwnd);
        break;
    case WM_CLOSE:
        ShowWindow(hwnd, SW_HIDE);
        return 0;
    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);
        if (hBackground) {
            HDC memDC = CreateCompatibleDC(hdc);
            HBITMAP oldBmp = (HBITMAP)SelectObject(memDC, hBackground);
            BITMAP bmp;
            GetObject(hBackground, sizeof(BITMAP), &bmp);
            BitBlt(hdc, 0, 0, bmp.bmWidth, bmp.bmHeight, memDC, 0, 0, SRCCOPY);
            SelectObject(memDC, oldBmp);
            DeleteDC(memDC);
        }
        EndPaint(hwnd, &ps);
        break;
    }
    case WM_HOTKEY:
    {
        int id = (int)wParam - HOTKEY_BASE;
        if (id >= 0 && id < HOTKEY_COUNT && wcslen(infoListW[id]) > 0) {
            setClipboardTextW(infoListW[id]);
            pasteClipboard();
        }
        break;
    }
    case WM_TRAYICON:
        if (lParam == WM_RBUTTONUP) {
            HMENU hMenu = CreatePopupMenu();
            AppendMenu(hMenu, MF_STRING, TRAY_MENU_OPEN, L"打开");
            AppendMenu(hMenu, MF_STRING, TRAY_MENU_EXIT, L"退出");
            POINT pt; GetCursorPos(&pt);
            SetForegroundWindow(hwnd);
            int cmd = TrackPopupMenu(hMenu, TPM_RETURNCMD | TPM_NONOTIFY, pt.x, pt.y, 0, hwnd, NULL);
            if (cmd == TRAY_MENU_OPEN) ShowWindow(hwnd, SW_SHOW);
            if (cmd == TRAY_MENU_EXIT) {
                Shell_NotifyIcon(NIM_DELETE, &nid);
                PostQuitMessage(0);
            }
            DestroyMenu(hMenu);
        } else if (lParam == WM_LBUTTONUP) {
            ShowWindow(hwnd, SW_SHOW);
        }
        break;
    case WM_DESTROY:
        Shell_NotifyIcon(NIM_DELETE, &nid);
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// -------------------- 主函数 --------------------
int WINAPI wWinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPWSTR lpCmdLine,int nShowCmd) {
    g_hInst = hInstance;
    GetConfigPath();
    InitConfig();

    WNDCLASSW wc = {0};
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L"AutoInputConfigWnd";
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    RegisterClassW(&wc);

    HWND hwnd = CreateWindowW(L"AutoInputConfigWnd", L"自动输入程序，By：Reinwi",
        WS_OVERLAPPEDWINDOW & ~(WS_THICKFRAME | WS_MAXIMIZEBOX),
        CW_USEDEFAULT, CW_USEDEFAULT, 500, 450,
        NULL, NULL, hInstance, NULL);

    // 复选框
    hCheckEnable = CreateWindowW(L"BUTTON", L"启用自动输入",
        WS_VISIBLE | WS_CHILD | BS_AUTOCHECKBOX,
        20, 20, 150, 30, hwnd, (HMENU)IDC_ENABLE_AUTO, NULL, NULL);
    hCheckStartup = CreateWindowW(L"BUTTON", L"开机启动",
        WS_VISIBLE | WS_CHILD | BS_AUTOCHECKBOX,
        200, 20, 150, 30, hwnd, (HMENU)IDC_STARTUP, NULL, NULL);

    // 输入框和标签
    for (int i = 0; i < HOTKEY_COUNT; i++) {
        wchar_t label[16]; swprintf(label, 16, L"Alt+%d", i+1);
        CreateWindowW(L"STATIC", label, WS_VISIBLE | WS_CHILD, 20, 70+i*30, 50, 25, hwnd, NULL, NULL, NULL);
        hEdit[i] = CreateWindowW(L"EDIT", infoListW[i], WS_VISIBLE | WS_CHILD | WS_BORDER | ES_AUTOHSCROLL,
            80, 70+i*30, 390, 25, hwnd, NULL, NULL, NULL);
    }

    CreateWindowW(L"BUTTON", L"保存", WS_VISIBLE | WS_CHILD,
        350, 370, 100, 30, hwnd, (HMENU)ID_SAVE_BUTTON, NULL, NULL);

    // 加载自定义图标（请替换为你的 .ico 文件路径）
    hAppIcon = LoadImageW(NULL, L"myicon.ico", IMAGE_ICON, 32, 32, LR_LOADFROMFILE);
    if (hAppIcon) {
        SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hAppIcon);
        SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hAppIcon);
    }

    // 托盘
    ZeroMemory(&nid, sizeof(nid));
    nid.cbSize = sizeof(NOTIFYICONDATA);
    nid.hWnd = hwnd;
    nid.uID = 1;
    nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
    nid.uCallbackMessage = WM_TRAYICON;
    nid.hIcon = hAppIcon ? hAppIcon : LoadIcon(NULL, IDI_APPLICATION);
    lstrcpyW(nid.szTip, L"自动输入程序运行中");
    Shell_NotifyIcon(NIM_ADD, &nid);

    LoadConfig(hwnd);

    // 静默启动判断
    int startup = GetPrivateProfileIntW(L"Settings", L"Startup", 0, configPath);
    ShowWindow(hwnd, startup ? SW_HIDE : nShowCmd);
    UpdateWindow(hwnd);

    MSG msg;
    while(GetMessageW(&msg, NULL, 0,0)){
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
    return 0;
}
